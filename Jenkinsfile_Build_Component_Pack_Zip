build_ok = true

// We want Jenkinsfile to be flexible to build any repo, but want to also not need to enter a ton of parameters/properties
// Users can override the GitHub repository to build by setting an environment variable named "custom_git_repo"

env.repos = 'deploy-services'
env.buildNodeExpression = 'Build_Component_Pack_Zip'

// buildNodeExpression is a parameter of the job, defined below
buildNodeExpression = env.buildNodeExpression

// Set job's workspace
if ( env.ws ) {
    ws = env.ws
} else {
    ws = "/local1/cnxbuild/Build_Component_Pack_Zip"
}

node(buildNodeExpression) {

    ws("${ws}") {
        // Set environment variables
        stage("Setting Environment Variables") {
            setEnvironmentVariables()
        }

        // Get build causes
        stage("Getting Build Causes") {
            getBuildCauses()
        }

        // Set build parameters
        stage("Setting Build Parameters & Properties") {
            setBuildParametersAndProperties()
        }

        // Checkout source
        stage("Fetching Source") {
            checkoutAndSetup()
        }

        // Print Environment Variables
        stage("Printing Environment Variables") {
            printEnvironmentVariables()
        }

        // Build
        stage("Building ${env.JOB_BASE_NAME}") {
            try {
                buildStage()
            } catch(e) {
                build_ok = false
                env.build_ok = false
                echo e.toString()
            }
        }

        // Create Summary
        stage("Creating Job Result Summary") {
            createSummary()
        }

        // Delete build area, only if job was successful
        stage("Delete Build Area") {
            if (manager.build.@result == hudson.model.Result.SUCCESS) {
                try {
                    echo "Job completed successfully, deleting ${env.WORKSPACE}"
                    deleteDir()
                } catch(e) {
                    echo e.toString()
                }
            } else {
                echo "Job did not complete successfully, will not delete ${env.WORKSPACE}"
            }
        }

    }
}

//**********************************************************************************************
//
// Functions
//
//**********************************************************************************************

void setEnvironmentVariables() {

    // The following used to create build label
    now = new Date()
    env.BUILD_TIMESTAMP = now.format("yyyyMMdd-HHmm", TimeZone.getTimeZone('America/New_York'))
    currentBuild.displayName = env.JOB_BASE_NAME + "_" + env.BUILD_TIMESTAMP
    currentBuild.description = ""

    // env.repos at the top of this Jenkinsfile is used to determine which repo's to pull
    if (env.custom_git_repo) {
        allRepos = env.custom_git_repo
    } else {
        allRepos = env.repos
        env.repos = repos
    }

    //allRepos = env.repos
    repoList = allRepos.split(",")

    if (env.gitURL) {
        gitURL = env.gitURL
    } else {
        gitURL = 'https://git.cwp.pnp-hcl.com/connections/'
        env.gitURL = gitURL
    }

    if (env.githubCredId) {
        githubCredId = env.githubCredId
    } else {
        githubCredId = 'connbld_github_api_token'
        env.githubCredId = githubCredId
    }

}

void getBuildCauses() {

    causes = currentBuild.getBuildCauses()
    echo "causes = ${causes}"
    if (causes) {
        env.BUILD_CAUSE = causes
    }

}

void setBuildParametersAndProperties() {

    properties([
        parameters([
            string(
                defaultValue: 'master',
                description: '<BR><font color="blue" size="4">Git branch (default: master)<BR><BR></font>',
                name: 'branchName',
            )
        ]),

        buildDiscarder(logRotator(
            //artifactDaysToKeepStr: '7',
            artifactNumToKeepStr: '25',
            //daysToKeepStr: '7',
            numToKeepStr: '25')
        )
    ])

    if (( "${params.branchName}" ) && ("${params.branchName}" != null )) {
        branchName = "${params.branchName}"
    } else {
        branchName = "master"
    }
    env.branchName = branchName

}

void checkoutAndSetup() {
    deleteDir()
    env.nullString = "null"

    if (repoList.size() > 1) {
        for (String repoName : repoList) {
            dir("${repoName}") {
            repoURL = gitURL + repoName
                mapVars = checkout([
                    $class: 'GitSCM',
                    branches: [[
                          name: branchName
                    ]],
                    doGenerateSubmoduleConfigurations: false,
                    extensions: [],
                    submoduleCfg: [],
                    userRemoteConfigs: [[
                        credentialsId: "${githubCredId}",
                        url: "${repoURL}"
                    ]]
                ])

                env.GIT_COMMIT = mapVars.get('GIT_COMMIT')
                env.GIT_PREVIOUS_COMMIT = mapVars.get('GIT_PREVIOUS_COMMIT')
                env.GIT_PREVIOUS_SUCCESSFUL_COMMIT = mapVars.get('GIT_PREVIOUS_SUCCESSFUL_COMMIT')
                env.repoSha = env.JOB_BASE_NAME + "_" + env.BUILD_TIMESTAMP + "," + env.GIT_COMMIT + "," + repoName + "," + branchName
                env.justSha = env.GIT_COMMIT + "," +  env.GIT_PREVIOUS_SUCCESSFUL_COMMIT

                if (isUnix()) {
                    sh """
                        echo ${env.repoSha} >> ../GIT_COMMIT_SHA.txt
                        echo ${env.justSha} >> ../GIT_JUST_SHA.txt
                        if [[ "${env.GIT_PREVIOUS_SUCCESSFUL_COMMIT}" == "${env.nullString}" ]]; then
                            echo "New repo" >> list_of_changes.txt
                        else
                            git diff --name-only ${env.GIT_PREVIOUS_SUCCESSFUL_COMMIT} ${env.GIT_COMMIT} >> ../list_of_changes.txt
                        fi
                    """
                }
            }
        }
    } else {
        for (String repoName : repoList) {
            repoURL = gitURL + repoName
            mapVars = checkout([
                $class: 'GitSCM',
                branches: [[
                      name: branchName
                ]],
                doGenerateSubmoduleConfigurations: false,
                extensions: [],
                submoduleCfg: [],
                userRemoteConfigs: [[
                    credentialsId: "${githubCredId}",
                    url: "${repoURL}"
                ]]
            ])

            env.GIT_COMMIT = mapVars.get('GIT_COMMIT')
            env.GIT_PREVIOUS_COMMIT = mapVars.get('GIT_PREVIOUS_COMMIT')
            env.GIT_PREVIOUS_SUCCESSFUL_COMMIT = mapVars.get('GIT_PREVIOUS_SUCCESSFUL_COMMIT')
            env.repoSha = env.JOB_BASE_NAME + "_" + env.BUILD_TIMESTAMP + "," + env.GIT_COMMIT + "," + repoName + "," + branchName
            env.justSha = env.GIT_COMMIT + "," +  env.GIT_PREVIOUS_SUCCESSFUL_COMMIT

            if (isUnix()) {
                sh """
                    echo ${env.repoSha} >> GIT_COMMIT_SHA.txt
                    echo ${env.justSha} >> GIT_JUST_SHA.txt

                    if [[ "${env.GIT_PREVIOUS_SUCCESSFUL_COMMIT}" == "${env.nullString}" ]]; then
                        echo "New repo" >> list_of_changes.txt
                    else
                        git diff --name-only ${env.GIT_PREVIOUS_SUCCESSFUL_COMMIT} ${env.GIT_COMMIT} >> list_of_changes.txt
                    fi
                """
            }
        }
    }
}

void printEnvironmentVariables() {

    echo "Environment Variables:\n\n"
    echo "WORKSPACE = ${WORKSPACE}\n"
    echo "BUILD_URL = ${BUILD_URL}\n"
    echo "JENKINS_HOME = ${JENKINS_HOME}\n"
    echo "JENKINS_URL = ${JENKINS_URL}\n"
    echo "JOB_URL = ${JOB_URL}\n"
    echo "BUILD_DISPLAY_NAME = ${BUILD_DISPLAY_NAME}\n"
    echo "JOB_NAME = ${JOB_NAME}"
    echo "JOB_BASE_NAME = ${JOB_BASE_NAME}"
    echo "branchName = ${branchName}"

}

void buildStage(){
    withCredentials([usernamePassword(credentialsId: 'connbld_artifactory_api_token', passwordVariable: 'ArtifactoryAPI', usernameVariable: 'ArtifactoryUser')]) {
        if (isUnix()){
            sh """
                /usr/bin/chmod -R 755 ${WORKSPACE}
            """
        }
    }

    // Since the above 'withCredentials' block is using the same credential, we could combine, although I've left separate in the event you want the first block to take action on the docker HOST, and have this block take action on the Docker CONTAINER
    withCredentials([usernamePassword(credentialsId: 'connbld_artifactory_api_token', passwordVariable: 'ArtifactoryAPI', usernameVariable: 'ArtifactoryUser')]) {

        // Define characteristics of the Docker registry & Dockerimage ( including Docker tag )
        docker_registry = 'buildutils-docker.artifactory.cwp.pnp-hcl.com'
        docker_image = 'cp-builder'
        docker_image_tag = '20210303-helm-v3.5.2'
        docker_group_id_on_host = '1002'

        docker.withRegistry("https://${docker_registry}") {

            docker.image("${docker_registry}/${docker_image}:${docker_image_tag}").pull()
            docker.image("${docker_registry}/${docker_image}:${docker_image_tag}").inside("-v /var/run/docker.sock:/var/run/docker.sock --group-add ${docker_group_id_on_host}") {

                sh """

                    whoami
                    echo PATH = ${PATH}
                    ps -ef |grep docker
                    ps -ef |grep helm
                    which docker
                    which helm
                    docker version
                    helm version

                    env
                    cd ${WORKSPACE}/scripts
                    ./createZip.sh -u $ArtifactoryUser -p $ArtifactoryAPI --push --csl

                    if [ \${?} -eq 0 ]; then
                        curl -SLO -u $ArtifactoryUser:$ArtifactoryAPI https://artifactory.cwp.pnp-hcl.com/artifactory/ibm-connections-cloud-docker/conncloud/docker-base-images/hybridcloud/mastered.sem
                        FILETOUPLOAD=`cat mastered.sem`
                        curl -SLO -u $ArtifactoryUser:$ArtifactoryAPI https://artifactory.cwp.pnp-hcl.com/artifactory/ibm-connections-cloud-docker/conncloud/docker-base-images/customizerLite/cs_mastered.sem
                        CS_FILETOUPLOAD=`cat cs_mastered.sem`

                        sleep 10
                    else
                        echo "Failure running createZip.sh"
                        exit 1
                    fi
                """
            }
        }
    }
}

void createSummary() {

        // Jenkins icon options --> https://github.com/jenkinsci/jenkins/tree/master/war/src/main/webapp/images/16x16
        // Groovy Post Build-provided options --> https://wiki.jenkins.io/display/JENKINS/Groovy+Postbuild+Plugin

        def git_commit_sha_exists = fileExists 'GIT_COMMIT_SHA.txt'
        if (git_commit_sha_exists) {
            archiveArtifacts artifacts: 'GIT_COMMIT_SHA.txt'
        }

        def list_of_changes_exists = fileExists 'list_of_changes.txt'
        if (list_of_changes_exists) {
            archiveArtifacts artifacts: 'list_of_changes.txt'
        }

        manager.addShortText("Docker host: ${buildNodeExpression}","blue","white","1px","white")
        manager.addShortText("Docker registry: ${docker_registry}","blue","white","1px","white")
        manager.addShortText("Docker image: ${docker_image}:${docker_image_tag}","blue","white","1px","white")
        manager.addShortText("Branch built: ${branchName}","blue","white","1px","white")

        if(build_ok) {
            manager.build.@result = hudson.model.Result.SUCCESS
            currentBuild.result = "SUCCESS"
        } else {
            manager.build.@result = hudson.model.Result.FAILURE
            currentBuild.result = "FAILURE"
        }
}
